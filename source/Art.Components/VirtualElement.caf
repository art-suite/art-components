import &StandardImport
{virtualElementPoolEnabled} = VirtualNode = &VirtualNode

devMode = &DevMode

class VirtualElement extends VirtualNode
  @abstractClass()

  @resetCounters: ->
    @created      = 0
    @instantiated = 0
    @reused       = 0
    @released     = 0

  @resetCounters()

  @getCounters: -> {@created, @instantiated}

  #####################
  # CONSTRUCTION
  #####################
  constructor: (elementClassName, props, children) ->
    VirtualElement.created++
    super props
    # throw new Error "blah" unless @_renderedIn
    @_initVirtualElement elementClassName, props, children

  init: (elementClassName, props, children) ->
    VirtualElement.reused++
    @_initVirtualNode props
    @_initVirtualElement elementClassName, props, children
    @

  emptyChildren = []
  _initVirtualElement: (elementClassName, props, children) ->
    @_elementClassName = elementClassName
    @_children = children ? emptyChildren
    @_validateChildren children if devMode
    @_element = null

  #####################
  # Getters
  #####################
  @getter "elementClassName released element",
    children: ->
      if !@_children
        throw new Error
          log.warn if @_released
                "Critical Failure: VirtualElement<#{@inspectedName}-#{@uniqueId}> was released! Should not be accessing children!"
          else  "Internal Failure: VirtualElement<#{@inspectedName}-#{@uniqueId}> has no children!"

      @_children

  #####################
  # Inspection
  #####################
  @getter
    inspectedName: ->
      {key, elementClassName} = @
      "Virtual-#{elementClassName}#{if key then "-" + key  else ''}"

    inspectedObjects: ->
      "#{@inspectedName}": @inspectedObjectsContents

    inspectedObjectsContents: ->
      if @children.length > 0
        compactFlattenAllFast {@props}, toInspectedObjects @children
      else {@props}

  findElements: (pattern, options, matches = []) ->
    if foundMatch = @testMatchesPattern pattern
      matches.push @

    if !foundMatch || options?.findAll
      each child in @children
        child.findElements pattern, options, matches
    matches

  eachInComponent: (f) ->
    super
    each child in @children
      child.eachInComponent f
    null

  #####################################
  # Specialization Overrides
  # Override these for custom ArtReact specializations (like ArtEngine)
  #####################################
  ### withElement
    Evaluate "f" in the thread the Element exists in.

    Example: For when React is running in a web-worker and the element
    is on the main threa.

    EFFECT: execute the function 'f' with the Concrete-Element associated with this VirtualElement.
    IN: (element) -> plainObjects
    OUT: promise returning function's plain-object-result

    PURPOSE: This is provided for the web-worker React so you can access the concrete element even though it is
      in another context. In that case, "f" will be serialized and any closure will be lost...

    OVERRIDE this to support web-workers - when concrete elements are on not in this worker-instance
  withElement: (f) ->
    new Promise (resolve) -> resolve f @_element

  ### sendToElement
    Lighter-weight than "withElement"

    IN:
      method: string
      args: 0 or more additional arguments
    OUT: promise returning function's plain-object-result

    Equivelent to:
      @withElement (element) -> element[method] args...
    OVERRIDE this to support web-workers - when concrete elements are on not in this worker-instance
  sendToElement: (method, args...) ->
    new Promise (resolve) -> resolve @_element[method] args...


  ## _updateElementProps
    EFFECT: @props has been updated and any props on the Concrete Element have been update
    OUT: true if props changed
  _updateElementProps: (newProps) ->

  ## _setElementChildren
    IN: childrenElement: array of concrete elements to be all the children for this element
  _setElementChildren: (childElements) ->

  ## _newElement
    OUT: new concrete element instance
  _newElement: (elementClassName, props, childElements)->
    elementClassName

  _newErrorElement: -> throw new Error "VirtualElement _newErrorElement not overridden"

  ##################
  # Specialization Helpers
  ##################
  # EFFECT: @props has been set to the newProps if they changed
  # OUT: true if props changed
  _updateElementPropsHelper: (newProps, addedOrChanged, removed) ->
    oldPropsLength = @getPropsLength()
    oldProps = @props

    noChangeCount = 0
    noChange = -> noChangeCount++

    # objectDiff: (o1, o2, added, removed, changed, nochange, eq = defaultEq, o2KeyCount) ->
    newPropsLength = @setPropsLength objectDiff newProps, oldProps, addedOrChanged, removed, addedOrChanged, noChange, propsEq

    if newPropsLength == noChangeCount && oldPropsLength == newPropsLength
      false
    else
      @props = @_rawProps = newProps
      true

  ########################
  ########################
  # PRIVATE
  ########################
  ########################

  ##########################################
  # VirtualNode Overrides
  ##########################################
  clone: ->
    new VirtualElement
      @elementClassName
      @props
      array child in @children
        child.clone()

  _captureRefs: (component) ->
    if component == @renderedIn
      if (key = @key)?
        log.warn "Duplicate key #{key} found in #{@inspectedPath}" if component._refs[key]
        component._refs[key] = @

      each child in @children
        child._captureRefs component

    null

  _resetAllProps: ->
    VirtualElement.released++
    @_resetVirtualNodeProps()

    each child in-array @_children
      child.release()

    @_elementClassName = @_children = null

  #################
  # UpdateFrom
  #################
  ## _canUpdateFrom
    IN: <VirtualElement>
    OUT: <Boolean>
      True if this VE is capable of updating itself to identically match
      the passed-in virtualElement
  _canUpdateFrom: (virtualElement)->
    @elementClassName == virtualElement.elementClassName &&
    @key == virtualElement.key

  _extractOldChildToUpdate: (child)->
    find oldChild, i in @children
      if oldChild?._canUpdateFrom child
        @children[i] = null
        oldChild

  ### _fastUpdateChildren
    OUT: <Boolean>
      TRUE if no Nodes were added, removed or changed "types"
      This implies @element.children didn't change.

    EFFECT:
      if no Nodes were added, removed or changed "types"
        run _updateFrom newChild for all oldChildren
      else noop; return false
  _fastUpdateChildren: (fromVirtualElement) ->
    newChildren = fromVirtualElement.children
    oldChildren = @children
    return false unless oldChildren.length == newChildren.length

    each oldChild, i in-array oldChildren
      return false unless oldChild._canUpdateFrom newChildren[i]

    each oldChild, i in-array oldChildren
      oldChild._updateFrom newChildren[i]

    true

  ## _slowUpdateChildren
    IN: fromVirtualElement <VirtualElement>
  _slowUpdateChildren: (fromVirtualElement) ->

    oldChildren = @children

    newChildren = array newChild from-array fromVirtualElement.children
      if oldChild = @_extractOldChildToUpdate newChild
            oldChild._updateFrom newChild
      else  newChild._instantiate @_parentComponent

    each child in oldChildren when child
      child._unmount()
      child.release() if virtualElementPoolEnabled

    fromVirtualElement._children = null if virtualElementPoolEnabled

    @_setElementChildren array child in-array newChildren
      child.element

    @_children = newChildren

  ## _updateChildren
    OUT: <Boolean> true if children changed
      if true, element.setChildren was called
      if false, the children individually may change, but
        this element's children are the same set
  _updateChildren: (fromVirtualElement) ->
    if @_fastUpdateChildren fromVirtualElement
      false
    else
      @_slowUpdateChildren fromVirtualElement
      true

  _unmount: ->
    each child in @children
      child._unmount()

  # returns this
  _updateFrom: (fromVirtualElement) ->
    unless @_element                  then throw new Error "VirtualElement._updateFrom: #{@inspectedName} no @_element"
    if fromVirtualElement._released   then log.error "updating from released VirtualElement: #{fromVirtualElement.inspectedName}"
    if @released                      then log.error "updating at released VirtualElement: #{@inspectedName}"
    if fromVirtualElement == @        then throw new Error "_updateFrom self!!!"

    propsChanged    = @_updateElementProps fromVirtualElement.props
    childrenChanged = @_updateChildren fromVirtualElement

    # each child, i in @_children
    #   if !child.element
    #     throw new Error "child #{i} #{child.inspectedName} not instantiated"
    #   log "#{@inspectedName} _updateFrom: child #{i} #{child.inspectedName} instantiated"

    ### VirtualElementPool:
      don't recurse on children -
      @_updateChildren will checkin the children that need checked in
      and NOT checkin the ones which will still be used
    if virtualElementPoolEnabled
      fromVirtualElement._children = null
      fromVirtualElement.release()

    # globalCount "ReactVirtualElement_UpdateFromTemporaryVirtualElement_#{if propsChanged || childrenChanged then 'Changed' else 'NoChange'}"

    @

  #####################
  # Instantiate
  #####################

  ### _instantiate
    create element or componentInstance
    fully generate Virtual-AIM subbranch
    fully create all AIM elements
    OUT: this
  _instantiate: (parentComponent) ->
    if parentComponent != @_renderedIn && parentComponent && @_renderedIn
      return @clone()._instantiate parentComponent

    super
    # log "VirtualElement._instantiate #{@inspectedName}"
    VirtualElement.instantiated++
    # globalCount "ReactVirtualElement_Instantiated"

    @_element = try
      instantiatedChildren = array child, childIndex in-array @children when
        child = @children[childIndex] = child._instantiate parentComponent

        child.element
        ? throw new Error "child(#{child.uniqueId}) #{childIndex}/#{@children.length} #{child.inspectedName} not instantiated"

      # log {} instantiatedChildren
      @_element = @_newElement
        @elementClassName
        @props
        instantiatedChildren

    catch error
      errors = true
      log.error VirtualElement._instantiate: {}
          error
          @elementClassName
          @props

      @_newErrorElement()

    throw new Error "VirtualElement._instantiate: no @_element" unless @_element?

    @
