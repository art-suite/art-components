import &StandardImport, &ArtObjectTreeFactory, &Helpers, {} &Counters
{virtualElementPoolEnabled} = VirtualNode = &VirtualNode

&ComponentEpoch extract componentEpoch
getEnv() extract artComponentsDebug

devMode = &DevMode

if ArtEngineCore = Neptune.Art.Engine?.Core
  {globalEpochCycle} = ArtEngineCore.GlobalEpochCycle

emptyProps = {}

class Component extends &StateFieldsMixin &InstanceFunctionBindingMixin VirtualNode
  @abstractClass()

  @nonBindingFunctions:
    :componentWillMount
    :componentWillUnmount
    :render

  @topComponentInstances: []
  @rerenderAll: ->
    each component in-array @topComponentInstances
      component.rerenderAll()

  @toComponentFactory: ->
    &Helpers extract objectTreeFactoryOptions

    createObjectTreeFactory
      objectTreeFactoryOptions
      @

  #########################
  # HOT RELOAD SUPPORT
  #########################
  @getModule: getModule = (spec = @prototype)->
    spec.module || spec.hotModule || getModuleBeingDefined()

  @getCanHotReload: -> @getModule()?.hot

  @_hotReloadUpdate: (@_moduleState) ->
    name = @getClassName()
    if hotInstances = @_moduleState.hotInstances
      log.warn "Art.React.Component #{@getName()} HotReload":
        instanceToRerender: hotInstances.length

      # update all instances
      each instance in-array hotInstances
        instance._componentDidHotReload()

  @postCreateConcreteClass: ({classModuleState, hotReloadEnabled})->
    super
    @_hotReloadUpdate classModuleState if hotReloadEnabled
    @toComponentFactory()

  #########################
  # INSTANCE
  #########################
  constructor: (props, children) ->
    Counters.componentCreated()

    props = if children
      propsChildren = {} children
      if props?
        merge props, propsChildren
      else propsChildren
    else props ? emptyProps

    super props

    @_componentDepth =
      @_renderedIn?._componentDepth ? 0
      + 1

    @state =

    @_refs =
    @_pendingState =
    @_pendingUpdates =
    @_virtualElements = null

    @_mounted =
    @_wasMounted =
    @_epochUpdateQueued = false

  clone: ->
    new @class @props

  release: ->
    log.warn "Component released - Only a partial release for now"
    @_virtualElements?.release @
    @_virtualElements = null
    @_refs = null

  ## withElement
    SEE: VirtualElement#withElement for more
    IN: f = (concreteElement) -> x
    OUT: promise.then (x) ->
  withElement: (f) -> @_virtualElements.withElement f

  rerenderAll: ->
    @_queueRerender()
    @eachSubcomponent (component) -> component.rerenderAll()
    null

  # OUT: this
  instantiateAsTopComponent: ->
    Component.topComponentInstances.push @
    @_instantiate()

  unbindTopComponent: ->
    unless 0 <= index = Component.topComponentInstances.indexOf @
      throw new Error "not a top component!"

    Component.topComponentInstances = arrayWithout Component.topComponentInstances, index
    @_unmount()

  ######################
  # INSPECTION
  ######################

  @getter
    inspectedName: -> "#{@className}#{if @key then "-"+@key  else ''}"
    inspectedObjects: (verbose) ->
      inspectedObjects = [@inspectedName]: merge {}
        @key
        props:    if objectHasKeys @props then merge @props
        state:    if objectHasKeys @state then merge @state
        rendered: @_virtualElements?.inspectedObjects

      if verbose
        {}
          class: @class.getNamespacePathWithExtendsInfo()
          @inspectedPathName
          inspectedObjects

      else
        inspectedObjects


    mounted: -> @_mounted
    element: -> @_virtualElements?.element

    subcomponents: ->
      ret = []
      @eachSubcomponent (c) -> ret.push c
      ret

    refs: ->
      unless @_refs
        @_refs = {}
        @_virtualElements?._captureRefs @

      @_refs

  eachSubcomponent: (f) ->
    @_virtualElements?.eachInComponent (node) ->
      f node if node instanceof Component

    null

  ### find - find components in this branch of the VirtualTree that match pattern
    IN
      pattern: one of:
        <String>
        <RegExp>
        (testString) -> t/f

      options:
        findAll: t/f  # by default find won't return children of matching Elements, set to true to return all matches
        verbose: t/f  # log useful information on found objects

      matches: internal use

    OUT: <Array Components>
  find: (pattern, options, matches = []) ->
    options extract? findAll, verbose

    if matchFound = @testMatchesPattern pattern
      matches.push @

    if verbose && (matchFound || verbose == :all)
      log merge {} matchFound, @inspectedName, functionResult: if pattern is Function then pattern @

    if !matchFound || findAll
      @eachSubcomponent (child) -> child.find pattern, options, matches

    matches

  findElements: (pattern, options, matches = []) ->

    if @_virtualElements
      if options?.verbose
        log "findElements in #{@inspectedName}"
      @_virtualElements.findElements pattern, options, matches

    matches


  ##############################
    propFields declaration
  ##############################
  @extendableProperty
    propFields: null

    # custom extender here only so propFiles can be initialized to null, not {}.
    # This is a performance optimization, but I'm dubious about if it does anything.
    # Need a concrete perf test to be sure, but I think we can just simplified all this down to propFields: {}
    # SBD (2018-Feb)
    extend: (extendedValue, addPropFields) ->
      mergeInto extendedValue ? {}, addPropFields

  ### @propFields
    Declare prop fields you intend to use.
    IN: fields
      map from field names to:
        default-values

    FUTURE-NOTE:
      If we decide we want more options than just 'default-values',
      we can add a new declarator: @propFieldsWithOptions
      where the map-to-values must all be options objects.

    EFFECTS:
      used to define getters for @prop
  ###
  @propFields: propFields = @_normalizeAndValidateObjectDeclarations (fields) ->
    @extendPropFields fields
    each defaultValue, field in-object fields
      @addGetter field, ~> @props[field]

  # ALIAS
  @propField: propFields


  ################################################
  # Component API (based loosly on Facebook.React)
  ################################################
  ### setState
    signatures:
      # update zero or more states via an plain object mapping keys to values;
      (newStateMapObject) ->
        sets state from each k-v pair in newStateMapObject

      # transform state during the enxt state-update epoch
      (stateUpdateFunction) ->
        during the next state-update-epoch, this function
        is applied to the state.

      # update one state-value (faster than creating an object just to update state)
      (stateKey, stateValue) ->
        set one state

    OUT: self

    stateUpdateFunction: (nextState) -> nextState
      Takes a nextState-object as input and returns a new
      nextState object or passes nextState directly through.
      EFFECT: can call setState; CANNOT modify nextState

  setState: (a, b) ->
    if isString a
      @_setSingleState a, b

    else if newState = a
      if isFunction newState
        @_queueUpdate newState

      else
        testState = @state
        _state = null
        each v, k in-object newState when @_pendingState || testState[k] != v
          _state ?= @_getStateToSet()
          _state[k] = v

      @

  ################################################
  # Component LifeCycle
  ################################################

  ### preprocessProps

    When:         Called on component instantiation and any time props are updated

    IN:           newProps - The props received from the render call which created/updated this component

    OUT:          plain Object - becomes @props. Can be newProps, based on newProps or entirely new.

    Guarantee:    @props will allways be passed through preprocessProps before it is set.
                  i.e. Your render code will never see a @props that hasen't been preprocessed.

    Be sure your preprocessProps: (requirements)
      - returns a plain Object
      - doesn't modify the newProps object passed in (create and return new object to add/alter props)
      - call super!

    Examples:
      # minimal
      preprocessProps: ->
        merge super, myProp: 123

      # a little of everything
      preprocessProps: ->
        newProps = super
        @setState foo: newProps.foo
        merge newProps, myProp: "dude: #{newProps.foo}"

    Okay:
      you can call @setState (Art.Flux.Component does exactly this!)

    Description:
      Either return exactly newProps which were passed in OR create a new, plain object.
      The returned object can contain anything you want.
      These are the props the component will see in any subsequent lifecycle calls.

    NOTE: Unique to Art.React. Not in Facebook's React.

    NOTES RE Facebook.React:
      Why add this? Well, often you want to apply a transformation to @props whenever its set OR it changes.
      With Facebook.React there is no one lifecycle place for this. Component instantiation/mounting
      and component updating are kept separate. I have found it is very error-prone to implement
      this common functionality manually on each component that needs it.
  ###
  preprocessProps: defaultPreprocessProps = (newProps) -> newProps

  ### preprocessState
    When:         preprocessState is called:
                    after preprocessProps
                    after componentWillUpdate
                    before rendering

    IN:           newState <Object> - the state which is proposed to become @state
                  isInitialState <Boolean> - true if first call, else false
    OUT:          object which will become @state. Can be newState, be based on newState or completely new.

    Guarantees:   @state will allways be passed through preprocessState before it is set.
                  i.e. Your render code will never see a @state that hasen't been preprocessed.

    NOTES RE Facebook.React:
      Why add this? Well, often you want to apply a transformation to @state whenever it is initialized
      OR it changes. With Facebook.React there is no one lifecycle place for this. Component
      instantiation/mounting and component updating are kept separate. I have found it is very
      error-prone to implement this common functionality manually on each component that needs it.

      An example of this is FluxComponents. They alter state implicitly as the subscription data comes in, and
      and component instantiation. preprocessState makes it easy to transform any data written via FluxComponents
      into a standard form.

    SBD NOTES TO SELF:
      I think:
        - it is OK to directly mutate newState, can we declare this offically part of the API?
        - calls to @setState in preprocessState will be applied NEXT epoch.
  ###
  preprocessState: defaultPreprocessState = (newState) -> newState

  ### componentWillMount
    Invoked once, immediately before the initial rendering occurs.
    ALLOWED: setState
    IN/OUT: ignored
  componentWillMount: defaultComponentWillMount = ->

  ### componentWillUnmount
    Invoked once, immediately before a component is unmounted.
    IN/OUT: ignored
  componentWillUnmount: defaultComponentWillUnmount = ->

  ### componentDidHotReload
    Called each time webpack hot-reloads a module.
    It is important that this change the components state to trigger a rerender.
  componentDidHotReload: ->
    count = (@state._hotModuleReloadCount || 0) + 1
    @setState _hotModuleReloadCount: count

  ######################
  # PRIVATE
  ######################
  _captureRefs: (component) ->
    if component == @renderedIn
      if key = @key
        component._refs[key] = @

      each child in-array @props.children
        child._captureRefs component

    @

  _getStateToSet: ->
    if @_wasMounted then @_getPendingState()
    else
      @state = {} if @state == emptyState
      @state

  _setSingleState: (stateKey, stateValue, callback) ->
    if @_pendingState || @state[stateKey] != stateValue
      @_getStateToSet()[stateKey] = stateValue

    stateValue

  _queueRerender: ->
    @_getPendingState()

  ### _setPendingState
    2016-12: I can't decide! Should we allow state updates on unmounted components or not?!?!
    RELVANCE: allowing state updates allows us to update animating-out Art.Engine Elements.
    This is useful, for example, to hide the TextInput Dom element

    I'm generally against updating unmounted components:
      - they don't get new props. Logically, since they are unmounted,
        they should have no props, yet they do. They would surely
        completely break if we set @props = {}.

      - Since they don't get new @props, there is no way for the parent-before-unmounting
        to control unmounted Components. If their state can change, their parent-before
        should have some control.

    BUT, we need a better answer for animating-out Components. There is a need for re-rendering them
    at the beginning and ending of their animating-out process.

    Animating-Out
      - Most things can probably be handled by 1 render just before animating-out starts. This
        is awkward to do manually: First render decides we are going to remove a sub-component, but
        doesn't - during that render - instead it tells that component it is about to be animated-out.
        Then, it queues another render where it actually removes the sub-component. And this must all
        be managed by the parent Component, when really it's 100% the child-component's concern.

      - What if a Component can request a "final render" just BEFORE it is unmounted? The parent Component's
        render runs, removing the child Component. Then ArtComponents detects the child needs unmounting, but just
        before it unmounts it, the child gets a re-render as-if it's props changed, though they didn't. This
        in turn will update any Element or child Components for their animating-out state. After that,
        the component will get no more renders - since it will then be unmounted and unmounted components don't
        get rendered.

      - Further, when we do this final render, we can signal it is "final" via @props.
        - have the component get a final-render notification (via a member function override).
          That function takes as inputs the last-good @props, and returns the final-render @props.
          If it returns null, there will be no final render. This is the default implementation.

        - I LIKE!

      - Conclusion: New Component override: (TODO - I think we should go for this solution!)

          finalRenderProps: (previousProps) -> null

        To request a final-render, all you need to do is add this to your Component:

          finalRenderProps: (previousProps) -> previousProps

        And you may find it handy to also do:

          finalRenderProps: (previousProps) -> merge previousProps, finalRender: true

        Then you can do something special for your final-render:

          render: ->
            {finalRender} = @props

            if finalRender ...

    DO WE NEED SOMETHING MORE POWERFUL?

      - Do we need more than 1 "final render" - during animating-out?
      - Do we need an animating-out-done render?
      - A general solution would be a "manual unmount" option. I don't love this, but
        I also don't love tying this explicitly to ArtEngine's animating-out features.

    To ENABLE updates on unmounted Components, remove: || !@_mounted
  _setPendingState: (pendingState) ->
    @_queueChangingComponentUpdates()
    @_pendingState = pendingState

  _queueChangingComponentUpdates: ->
    unless @_epochUpdateQueued
      @_epochUpdateQueued = true
      componentEpoch.addChangingComponent @

  _queueUpdate: (updateFunction) ->
    @_queueChangingComponentUpdates()
    (@_pendingUpdates ?= []).push updateFunction

  _getPendingState: ->
    @_pendingState || @_setPendingState {}

  _unmount: ->
    @_removeHotInstance()
    @_componentWillUnmount()

    @_virtualElements?._unmount()
    @_mounted = false

  _addHotInstance: ->
    if moduleState = @class._moduleState
      (moduleState.hotInstances ||= []).push @

  _removeHotInstance: ->
    if moduleState = @class._moduleState
      {hotInstances} = moduleState
      if hotInstances && 0 <= index = hotInstances.indexOf @
        moduleState.hotInstances = arrayWithout hotInstances, index

  ## _instantiate
    OUT: this
  emptyState = {}
  _instantiate: (parentComponent, parentVirtualNode) ->
    if parentComponent != @_renderedIn && parentComponent? && @_renderedIn?
      return @clone()._instantiate parentComponent, parentVirtualNode

    super

    Counters.componentInstantiated()

    @bindFunctionsToInstance()
    @_addHotInstance()

    @state ?= emptyState

    @props = @_preprocessProps @props, true
    @_componentWillMount()

    stateAfterPossibleSetState = @state

    stateFields = @getStateFields()
    @class extract emptyStateFields
    haveStateFields       = stateFields != emptyStateFields
    haveStateFromSetState = stateAfterPossibleSetState != emptyState

    @state = emptyState # @preprocessState is allowed to inspect @state
    @state = @_preprocessState
      switch
        when haveStateFields && haveStateFromSetState
          merge stateFields, stateAfterPossibleSetState
        when haveStateFields        then stateFields
        when haveStateFromSetState  then stateAfterPossibleSetState
        else emptyState

      true

    @_instantiateVirtualElements()

    @_wasMounted = @_mounted = true
    @

  _instantiateVirtualElements: ->
    if @_virtualElements = @_render()
      VirtualNode.currentlyRendering = @
      @_virtualElements._instantiate @, @
      VirtualNode.currentlyRendering = null

  _render: ->
    # <performance monitoring>
    start = globalEpochCycle?.startTimePerformance()
    Counters.componentRendered()

    log "render component: #{@className}" if artComponentsDebug

    @_refs = null
    VirtualNode.currentlyRendering = @
    try
      rendered = @render()
      unless rendered instanceof VirtualNode
        @_reportInvalidRenderResult rendered

    catch error
      log.error "Error rendering #{@inspectedPath}", error
      rendered = null

    VirtualNode.currentlyRendering = null

    # <performance monitoring>
    globalEpochCycle?.endTimePerformance "reactRender", start
    # </performance monitoring>

    rendered

  _canUpdateFrom: (b)->
    @class == b.class &&
    @key == b.key

  _shouldReRenderComponent: (componentInstance) ->
    @_propsChanged(componentInstance) || @_pendingState

  # renders the component and updates the Virtual-AIM as needed.
  _reRenderAndUpdateComponent: ->

    unless @_virtualElements
      @_instantiateVirtualElements()
    else if newRenderResult = @_render()

      if @_virtualElements._canUpdateFrom newRenderResult
        # log "Component._reRenderAndUpdateComponent _updateFrom #{newRenderResult.inspectedName}/#{newRenderResult.uniqueId}"
        VirtualNode.currentlyRendering = @
        @_virtualElements._updateFrom newRenderResult
        VirtualNode.currentlyRendering = null

      else if @ extract parentVirtualElement
        @_virtualElements?._unmount()
        @_virtualElements = newRenderResult
        ._instantiate @
        parentVirtualElement._updateElementChildrenFromVirtualChildren()

      else @_reportInvalidRenderResult newRenderResult

    null

  ## _reportInvalidRenderResult
  _reportInvalidRenderResult: (newRenderResult) ->
    log.error
      "" Art.Components Component Reneer Error: (render ignored)\n\n
      + if newRenderResult instanceof VirtualNode
        """
          The render function's top-level Component/VirtualElement changed
          too much: The VirtualNode returned by a component's render function
          cannot change its Type or Key if it is the root node of the entire
          virtual tree.

          Solution: Wrap your changing VirtualNode with a non-changing VirtualElement.

      else
        """
          Invalid render result. Must return a VirtualElement or Component instance.

    log invalidRenderDetails:
      component:              @getInspectedObjects true
      invalidRenderResult:    newRenderResult
      keyChanged:             @_virtualElements?.key != newRenderResult?.key
      typeChanged:
        @_virtualElements?.class != newRenderResult?.class
        || @_virtualElements.elementClassName != newRenderResult.elementClassName

  ## _updateFrom
    EFFECT:
      1. Modifies @ to be an exact clone of componentInstance.
      2. Updates the true-Elements as we go.

    OUT: @
  _updateFrom: (componentInstance) ->
    if @_shouldReRenderComponent componentInstance
      @_applyPendingState componentInstance.props

    @

  ## _resolvePendingStateUpdates
    Clears out @_pendingUpdates and @_pendingState, applying them all to 'state' as passed-in.

    NOTE:
      This is a noop if @_pendingUpdates and @_pendingState are null.
      OldState is returned without any work done.

    ASSUMPTIONS:
      if @_pendingState is set, it is an object we are allowed to mutate
        It will be mutated and be the return-value of this function.

    EFFECTS:
      oldState is NOT modified
      @_pendingState and @_pendingUpdates are null and have been applied to oldState

    OUT: state is returned as-is unless @_pendingState or @_pendingUpdates is set
  _resolvePendingStateUpdates: ->
    oldState = @state

    if newState = @_pendingState
      object v, k from-object oldState into newState when newState[k] == undefined
      @_pendingState = null

    if @_pendingUpdates
      newState ?= merge oldState

      each updateFunction in-array @_pendingUpdates
        newState = updateFunction.call @, newState

      @_pendingUpdates = null

    newState ? oldState

  ## _applyPendingState
    NOTES:
      - newProps is non-null if this component is being updated from a non-instantiated Component.
      - This is where @props gets set for any update, but not where it gets set for component initializiation.

    NOTE: User-overridable @componentWillReceiveProps is allowed to call @setState.
      @componentWillReceiveProps is DEPRICATED. use @preprocessProps

    NOTE: Any updates state-changes triggered in @componentDidUpdate will be delayed until next epoch
      @componentDidUpdate is DEPRICATED. use @render, check if not-first render; if you care
  _applyPendingState: (newProps) ->
    return unless @_epochUpdateQueued || newProps

    Counters.componentUpdated()

    @_epochUpdateQueued = false

    oldProps = @props
    oldState = @state

    if newProps
      @props = @_preprocessProps
        @_rawProps = newProps
        false

    @state = @_preprocessState
      @_resolvePendingStateUpdates()
      false

    @_reRenderAndUpdateComponent()


  ### _updateComponent
    IN:
      newProps: if set, replaces props
      newState:

    NOTE: @componentWillUpdate
      @componetWillUpdate is DEPRICATED - use preprocessState
      User-overridable @componentWillUpdate is allowed to call @setState.
      Any updates state-changes triggered in @componentWillUpdate will be applied immediately
      after @componetWillUpdate completes. The newState object passed to @componetWillUpdate is
      not modified.

    NOTE: @preprocessState
      User-overridable @preprocessState is allowed to call @setState.
      Any updates state-changes triggered in @preprocessState will be delayed until next epoch
      @_preprocessState assumes @props has already been updated

  ########################
  # PRIVATE
  # LifeCycle Management
  ########################

  ###
    NOTE: The reason for defaultComponent* values instead of making the defaults NULL
      is so inheritors can call "super" safely.
    IDEA: We could make createComponentFactory gather up all custom life-cycle functions,
      and execute each in sequence therefor they don't need to call super.
      We could also enable mixins this way.
    2019: Better - let's make these lifecycle functions @extendableProperties

  _preprocessProps: (props, firstCall) ->
    if propFields = @getPropFields()
      merge propFields, props
    else props

    # props = super props # triggers PropFieldsMixin - which will include any default values from @propFields
    return props if defaultPreprocessProps == @preprocessProps
    try @preprocessProps props, firstCall
    catch error
      @_logLifeCycleError error
      props

  _preprocessState: (state, firstCall) ->
    return state if defaultPreprocessState == @preprocessState
    try @preprocessState state, firstCall
    catch error
      @_logLifeCycleError error
      state

  _componentDidHotReload: ->
    @bindFunctionsToInstance true
    try @componentDidHotReload()
    catch error
      @_logLifeCycleError error

    null

  _componentWillMount:    -> @_doCustomLifeCycle defaultComponentWillMount,   @componentWillMount,   null
  _componentWillUnmount:  -> @_doCustomLifeCycle defaultComponentWillUnmount, @componentWillUnmount, null

  _doCustomLifeCycle: (defaultLifeCycle, customLifeCycle, defaultReturnValue) ->
    if defaultLifeCycle != customLifeCycle
      try
        customLifeCycle.call @
      catch error
        @_logLifeCycleError error
        defaultReturnValue
    else defaultReturnValue

  _logLifeCycleError: (error) ->
    log.error ArtComponents_lifeCycle: {} error, Component: @
